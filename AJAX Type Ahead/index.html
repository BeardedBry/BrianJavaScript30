<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Ajax Type Ahead</title>
  <link rel="stylesheet" href="style.css"> 
</head>
<body>
    <main>
        <form class="search">
            <input id="textArea" placeholder="City or State">
        </form>
        <h3 class="subTitle">Filter by a City or State</h3>
        <div id="results">
        </div>
    </main>
    <script>
        const ENDPOINT = 'https://gist.githubusercontent.com/Miserlou/c5cd8364bf9b2420bb29/raw/2bf258763cdddd704f8ffd3ea9a3e81d25e2c6f6/cities.json';

        let data, eRegex, stateTxt, lastTxtField;
        const DISPLAY_DATA = [];

        fetch(ENDPOINT).then((d) => d.json()).then(newData => data = newData);

        const txt = document.getElementById('textArea');
        const results = document.getElementById('results');

        txt.addEventListener( 'input', (e)=> {
            stateTxt = e.target.value; // Control typed in data.
            txt.value = stateTxt;
            eRegex = new RegExp(`${stateTxt.trim()}`,'gi');

            txt.addEventListener('keyup', (event) => {

                console.log(stateTxt);
                // Refine search
                let currentEntries = [] //[...document.querySelectorAll('div > p')];

                // if(currentEntries.length > 0){ 
                //     console.log(currentEntries);
                //     currentEntries.forEach((entry) => {
                //         if (!entry.innerText.match(eRegex)){
                //             entry.parentElement.removeChild(entry);
                //         }
                //     })
                // }

                // Search and filter
                
                // PLAN IS TO FILTER THE DATA PER SEARCH, FILTER THE ALREADY DISPLAYED DATA, REMOVE WHAT ISNT IN THE NEW SEARCH, ADD WHATS MISSING. WIP

                for( let i=0; i < data.length; i++ ) {
                    
                    if( data[i].state.match(eRegex) || data[i].city.match(eRegex) ) {

                        currentEntries.push(data[i]); 
    
                        for( let inner = 0; inner < currentEntries.length; inner++ ) { // Inner loop to check entries
                            
                        }

                    }

                }

                displayData = data.filter((d) => {

                    return d.city.match(eRegex);
                })


                displayData.forEach(element => {
                    let newP = document.createElement('P');
                    newP.innerText = `${element.city}`;
                    results.appendChild(newP);
                });
            });
        });

      






        // txt.addEventListener('input',(e)=>{
        //     eRegex = new RegExp(`${e.target.value.trim()}`,'gi');
        //     let currentEntries = document.querySelectorAll('div > p');

        // // Refine search
        //     if(currentEntries.length > 0){ 
        //         console.log(currentEntries);
        //         currentEntries.forEach((item) => {
        //             if (!item.innerText.match(eRegex)){
        //                 item.parentElement.removeChild(item);
        //             }
        //         })
        // // Initial Search
        //     }else if(txt.value.length <= 1 || lastTxtField > txt.value.length){
        //         displayData = data.filter((d) => {
        //             return d.city.match(eRegex);
        //         })
        //         displayData.forEach(element => {
        //         let newP = document.createElement('P');
        //         newP.innerText = `${element.city}`;
        //         results.appendChild(newP);
        //     });
        //     }
        //     lastTxtField = txt.value.length;
          
        // })
      
    </script>
  </body>
</html>